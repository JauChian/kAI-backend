# kaiapp/views_generate.py
import json
from decimal import Decimal
from typing import Iterable
import calendar
import random
from datetime import date
from django.db.models import Q
from django.utils import timezone
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.db.models import QuerySet
from openai import OpenAI
from .models import Ingredient, Meal, RecipeIngredient, Dietary
from .serializers import MealSerializer
from .services import validate_menu, compute_totals
from .prompts import build_menu_prompt   

client = OpenAI()


# ---------- helpers ----------
DIETARY_CANONICAL = {
    "standard": "Standard",
    "vegan": "Vegan",
    "vegetarian": "Vegetarian",
    "halal": "Halal",
    "gluten-free": "Gluten-free",
    "gluten_free": "Gluten-free",
    "glutenfree": "Gluten-free",
}

def normalize_dietary(name: str | None) -> str:
    """
    Normalize dietary string input (case-insensitive, handles aliases).
    Examples:
        - "vegan", "Vegan" -> "Vegan"
        - "gluten_free" -> "Gluten-free"
        - None or unknown -> "Standard"
    """
    if not name:
        return "Standard"
    key = name.strip().lower()
    return DIETARY_CANONICAL.get(key, "Standard")

def get_ingredients_for_dietary(dietary: str) -> QuerySet[Ingredient]:
    """
    - Standard: all ingredients
    - Others: Ingredient that has that Dietary tag (ManyToMany)
    """
    if dietary == "Standard":
        return Ingredient.objects.all().order_by("name")
    return (
        Ingredient.objects
        .filter(dietaries__name__iexact=dietary)
        .distinct()
        .order_by("name")
    )

def to_prompt_block(ings: Iterable[Ingredient]) -> str:
    """
    Convert ingredients to the concise block the prompt expects:
    'name, price_per_100g, energy_kj'
    """
    lines = []
    for i in ings:
        price = f"{i.price_per_100g:.2f}"
        kj = f"{i.energy_kj:.0f}"
        lines.append(f"{i.name}, {price}, {kj}")
    return "\n".join(lines)


# ---------- views ----------
class GenerateMenusView(APIView):
    """
    POST /api/generate-menus/
    Body (JSON):
      {
        "batch_size": 5,          # optional, default 5
        "dietary": "Vegan"        # optional, default "Standard"
      }
    Response 201:
      { "saved": [ <MealSerializer with totals...> ] }
    """
    def post(self, request):
        # Parse batch_size from request (default 5)
        try:
            batch_size = int(request.data.get("batch_size", 5))
        except Exception:
            return Response({"error": "batch_size must be an integer."}, status=status.HTTP_400_BAD_REQUEST)
        
        # Normalize dietary string
        dietary = normalize_dietary(request.data.get("dietary"))
        # Filter available ingredients
        qs = get_ingredients_for_dietary(dietary)

        # If not enough ingredients, abort early (GPT can't build valid menus)
        if qs.count() < 6:
            return Response(
                {"error": f"Not enough ingredients for dietary '{dietary}'. Please add more."},
                status=status.HTTP_400_BAD_REQUEST,
            )
            
        # Build GPT prompt
        ingredients_block = to_prompt_block(qs)
        prompt = build_menu_prompt(ingredients_block, batch_size=batch_size, dietary=dietary)

        # ---- call GPT
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            response_format={"type": "json_object"},
            temperature=0.4,
            messages=[{"role": "user", "content": prompt}],
        )

        # ---- parse JSON
        try:
            payload = json.loads(resp.choices[0].message.content)
            menus = payload.get("menus", [])
            if not isinstance(menus, list):
                raise ValueError("`menus` must be a list.")
        except Exception:
            return Response({"error": "Model did not return valid JSON."}, status=status.HTTP_400_BAD_REQUEST)

        saved_meals = []

        # ---- validate + save to DB
        for m in menus:
            meal_name = m.get("meal_name", "Unknown Meal")
            items = m.get("items") or []
            ok, data = validate_menu(items, min_kj=2000, max_cost=3.5, min_g=200, max_g=500)

            if not ok:
                print(f"Menu failed: {meal_name}")
                print(f"Reason: {data}")  
                continue

            meal_name = (m.get("meal_name") or "Generated Meal").strip()[:160]
            desc = (m.get("description") or "Generated by GPT").strip()

            dietary_name = m.get("dietary") or dietary
            dietary_name = normalize_dietary(dietary_name)
            dietary_obj, _ = Dietary.objects.get_or_create(name=dietary_name)

            meal = Meal.objects.create(
                name=meal_name,
                description=desc,
                dietary=dietary_obj,
            )

            # attach items
            failed = False
            for it in items:
                ing = Ingredient.objects.filter(name__iexact=it.get("name", "")).first()
                if not ing:
                    failed = True
                    break
                try:
                    qty = Decimal(str(it["quantity_g"]))
                except Exception:
                    failed = True
                    break
                RecipeIngredient.objects.create(recipe=meal, ingredient=ing, quantity_g=qty)

            # Rollback if any item failed
            if failed:
                meal.delete()
                continue

            # augment totals for response (server-truth computation)
            db_items = [
                {"name": ri.ingredient.name, "quantity_g": ri.quantity_g}
                for ri in meal.items.select_related("ingredient").all()
            ]
            total_kj, total_cost = compute_totals(db_items)

            # Serialize meal + add computed totals
            serialized = MealSerializer(meal).data
            serialized["total_energy_kj"] = float(total_kj)
            serialized["total_cost"] = float(total_cost)
            saved_meals.append(serialized)

        if not saved_meals:
            return Response({"message": "No valid menus generated this round."}, status=status.HTTP_200_OK)

        return Response({"saved": saved_meals}, status=status.HTTP_201_CREATED)

DIETARY_CANONICAL = {
    "standard": "Standard",
    "vegan": "Vegan",
    "vegetarian": "Vegetarian",
    "halal": "Halal",
    "gluten-free": "Gluten-free",
    "gluten_free": "Gluten-free",
    "glutenfree": "Gluten-free",
}

def normalize_dietary(name: str | None) -> str:
    """
    將各種寫法（vegan / Vegan / GLUTEN_FREE ...）正規化成資料庫用的名稱。
    如果傳 None 或未知字串，回傳 'Standard'
    """
    if not name:
        return "Standard"
    key = str(name).strip().lower()
    return DIETARY_CANONICAL.get(key, "Standard")



class MonthlyMenuView(APIView):
    """
    GET /api/monthly-menu/?dietary=Standard

    Generate a "monthly calendar menu" for the next month.
    - Only assigns meals to weekdays (Mon–Fri).
    - Each weekday is randomly assigned an available meal.

    Response example:
    {
      "startDay": 3,          # Sunday=0 ... Saturday=6 (weekday of 1st day of month)
      "daysInMonth": 30,
      "menuItems": [
        { "date": "2025-09-01", "mealId": "12", "menuName": "Karaage Crunch Bowl" },
        ...
      ]
    }
    """
    def get(self, request):
        # 1) Target month = next calendar month
        today = timezone.localdate()
        if today.month == 12:
            year, month = today.year + 1, 1
        else:
            year, month = today.year, today.month + 1

        first_day = date(year, month, 1)
        days_in_month = calendar.monthrange(year, month)[1]
        # Python weekday(): Mon=0..Sun=6, but frontend expects Sun=0..Sat=6
        start_day = (first_day.weekday() + 1) % 7

        # 2) Filter meals by dietary type (default Standard)
        dietary = normalize_dietary(request.GET.get("dietary") or "Standard")

        qs = Meal.objects.all()
        if dietary == "Standard":
            # Standard includes meals explicitly tagged Standard OR with no dietary tag
            qs = qs.filter(Q(dietary__name__iexact="Standard") | Q(dietary__isnull=True))
        else:
            qs = qs.filter(dietary__name__iexact=dietary)

        meals = list(qs)
        if not meals:
            return Response(
                {"error": f"No meals available for dietary '{dietary}'."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # 3) Assign a random meal to each weekday (Mon–Fri), repeat allowed
        menu_items = []
        for day in range(1, days_in_month + 1):
            d = date(year, month, day)
            wd = d.weekday()  # Mon=0..Sun=6
            if wd <= 4:       # 只排週一~週五
                m = random.choice(meals)
                menu_items.append({
                    "date": d.isoformat(),
                    "mealId": str(m.id),
                    "menuName": m.name,
                })

        payload = {
            #"year": year,
            #"month": month,
            "startDay": start_day,
            "daysInMonth": days_in_month,
            "menuItems": menu_items,
        }
        return Response(payload, status=status.HTTP_200_OK)
